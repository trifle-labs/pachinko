import React, { useState, useRef } from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';

const PachinkoPinEditor = () => {
const [pins, setPins] = useState([]);
const [isDragging, setIsDragging] = useState(false);
const [selectedPin, setSelectedPin] = useState(null);
const [selectedPocket, setSelectedPocket] = useState(null);
const [mirroringEnabled, setMirroringEnabled] = useState(false);
const [mode, setMode] = useState('single');
const [linePoints, setLinePoints] = useState([]);
const [previewLine, setPreviewLine] = useState(null);
const [isErasing, setIsErasing] = useState(false);
const [pockets, setPockets] = useState([]);
const [pocketType, setPocketType] = useState('a');
const svgRef = useRef(null);
const CENTER_ZONE_WIDTH = 10; // 5px on each side of center

const POCKET_COLORS = {
a: '#FF4B4B',
b: '#4CAF50',
c: '#2196F3'
};

const POCKET_SIZE = 6; // Base size for pockets (will render as 6*2 = 12px diameter)

const getCoordinates = (e) => {
const svgRect = svgRef.current.getBoundingClientRect();
return {
x: e.clientX - svgRect.left,
y: e.clientY - svgRect.top,
centerX: svgRect.width / 2
};
};

const getMirroredX = (x) => {
const centerX = svgRef.current.getBoundingClientRect().width / 2;
return centerX + (centerX - x);
};

const isInCenterZone = (x) => {
const centerX = svgRef.current.getBoundingClientRect().width / 2;
return Math.abs(x - centerX) <= CENTER_ZONE_WIDTH / 2; }; const getCenterX=()=> {
  return svgRef.current.getBoundingClientRect().width / 2;
  };

  const eraseAtPoint = (x, y, radius = 15) => {
  setPins(pins.filter(pin => {
  const dx = pin.x - x;
  const dy = pin.y - y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  return distance > radius;
  }));
  setPockets(pockets.filter(pocket => {
  const dx = pocket.x - x;
  const dy = pocket.y - y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  return distance > radius;
  }));
  };

  const createPinsAlongLine = (start, end, spacing = 5) => {
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const numPins = Math.floor(distance / spacing);

  if (numPins < 1) return []; const newPins=[]; for (let i=0; i <=numPins; i++) { const t=i / numPins; const x=start.x +
    dx * t; const y=start.y + dy * t; if (mirroringEnabled && isInCenterZone(x)) { newPins.push({ x: getCenterX(), y,
    id: Date.now() + i }); } else { newPins.push({ x, y, id: Date.now() + i }); if (mirroringEnabled &&
    !isInCenterZone(x)) { const mirroredX=getMirroredX(x); newPins.push({ x: mirroredX, y, id: Date.now() + i + 1000 });
    } } } return newPins; }; const handleClick=(e)=> {
    if (isDragging) return;

    const { x, y } = getCoordinates(e);

    if (mode === 'pocket') {
    const newPocket = { x, y, type: pocketType, id: Date.now() };

    if (mirroringEnabled && isInCenterZone(x)) {
    setPockets([...pockets, { ...newPocket, x: getCenterX() }]);
    } else {
    const newPockets = [newPocket];

    if (mirroringEnabled && !isInCenterZone(x)) {
    const mirroredX = getMirroredX(x);
    newPockets.push({ ...newPocket, x: mirroredX, id: Date.now() + 1 });
    }

    setPockets([...pockets, ...newPockets]);
    }
    return;
    }

    if (mode === 'single') {
    if (mirroringEnabled && isInCenterZone(x)) {
    setPins([...pins, { x: getCenterX(), y, id: Date.now() }]);
    } else {
    const newPins = [...pins, { x, y, id: Date.now() }];

    if (mirroringEnabled && !isInCenterZone(x)) {
    const mirroredX = getMirroredX(x);
    newPins.push({ x: mirroredX, y, id: Date.now() + 1 });
    }

    setPins(newPins);
    }
    } else if (mode === 'line') {
    const point = { x, y };

    if (linePoints.length === 0) {
    setLinePoints([point]);
    } else if (linePoints.length === 1) {
    const newPins = createPinsAlongLine(linePoints[0], point);
    setPins([...pins, ...newPins]);
    setLinePoints([]);
    setPreviewLine(null);
    }
    }
    };

    const handleMouseMove = (e) => {
    const { x, y } = getCoordinates(e);

    if (mode === 'erase' && isErasing) {
    eraseAtPoint(x, y);
    return;
    }

    if (isDragging) {
    if (selectedPin) {
    const updatedPins = [...pins];
    const pinIndex = pins.findIndex(p => p.id === selectedPin.id);

    if (pinIndex === -1) return;

    if (mirroringEnabled && isInCenterZone(x)) {
    updatedPins[pinIndex] = { ...selectedPin, x: getCenterX(), y };
    } else {
    updatedPins[pinIndex] = { ...selectedPin, x, y };

    if (mirroringEnabled && !isInCenterZone(x)) {
    const originalX = selectedPin.x;
    const mirroredOriginalX = getMirroredX(originalX);

    const mirroredPinIndex = pins.findIndex(p =>
    Math.abs(p.y - selectedPin.y) < 1 && Math.abs(p.x - mirroredOriginalX) < 1 ); if (mirroredPinIndex !==-1) {
      updatedPins[mirroredPinIndex]={ ...pins[mirroredPinIndex], x: getMirroredX(x), y }; } } } setPins(updatedPins); }
      else if (selectedPocket) { const updatedPockets=[...pockets]; const pocketIndex=pockets.findIndex(p=> p.id ===
      selectedPocket.id);

      if (pocketIndex === -1) return;

      if (mirroringEnabled && isInCenterZone(x)) {
      updatedPockets[pocketIndex] = { ...selectedPocket, x: getCenterX(), y };
      } else {
      updatedPockets[pocketIndex] = { ...selectedPocket, x, y };

      if (mirroringEnabled && !isInCenterZone(x)) {
      const originalX = selectedPocket.x;
      const mirroredOriginalX = getMirroredX(originalX);

      const mirroredPocketIndex = pockets.findIndex(p =>
      Math.abs(p.y - selectedPocket.y) < 1 && Math.abs(p.x - mirroredOriginalX) < 1 ); if (mirroredPocketIndex !==-1) {
        updatedPockets[mirroredPocketIndex]={ ...pockets[mirroredPocketIndex], x: getMirroredX(x), y }; } } }
        setPockets(updatedPockets); } } else if (mode==='line' && linePoints.length===1) { setPreviewLine({ start:
        linePoints[0], end: { x, y } }); } }; const startDragging=(e, pin)=> {
        e.stopPropagation();
        e.preventDefault();
        setIsDragging(true);
        setSelectedPin(pin);
        };

        const stopDragging = () => {
        setIsDragging(false);
        setSelectedPin(null);
        };

        const removePin = (e, pinToRemove) => {
        e.stopPropagation();

        if (mirroringEnabled) {
        const mirroredX = getMirroredX(pinToRemove.x);
        setPins(pins.filter(pin =>
        pin.id !== pinToRemove.id &&
        !(Math.abs(pin.y - pinToRemove.y) < 1 && Math.abs(pin.x - mirroredX) < 1) )); } else { setPins(pins.filter(pin=>
          pin.id !== pinToRemove.id));
          }
          };

          const exportCoordinates = () => {
          const coordinates = {
          pins: pins.map(pin => ({
          x: Math.round(pin.x),
          y: Math.round(pin.y)
          })),
          pockets: pockets.map(pocket => ({
          x: Math.round(pocket.x),
          y: Math.round(pocket.y),
          type: pocket.type
          }))
          };
          console.log(JSON.stringify(coordinates, null, 2));
          };

          return (
          <Card className="w-full max-w-4xl">
            <CardHeader>
              <CardTitle>Pachinko Pin Layout Editor</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="flex items-center space-x-4 mb-4">
                  <div className="flex items-center space-x-2">
                    <input type="checkbox" id="mirror-toggle" checked={mirroringEnabled} onChange={()=>
                    setMirroringEnabled(!mirroringEnabled)}
                    className="w-4 h-4"
                    />
                    <label htmlFor="mirror-toggle" className="text-sm text-gray-600">
                      Enable Mirroring
                    </label>
                  </div>

                  <div className="flex items-center space-x-2">
                    <select value={mode} onChange={(e)=> {
                      setMode(e.target.value);
                      setLinePoints([]);
                      setPreviewLine(null);
                      }}
                      className="border rounded px-2 py-1"
                      >
                      <option value="single">Single Pin</option>
                      <option value="line">Line of Pins</option>
                      <option value="pocket">Add Pockets</option>
                      <option value="erase">Erase</option>
                    </select>
                    {mode === 'pocket' && (
                    <select value={pocketType} onChange={(e)=> setPocketType(e.target.value)}
                      className="border rounded px-2 py-1"
                      >
                      <option value="a">Pocket A</option>
                      <option value="b">Pocket B</option>
                      <option value="c">Pocket C</option>
                    </select>
                    )}
                    <button onClick={()=> {
                      setPins([]);
                      setPockets([]);
                      }}
                      className="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700 text-sm"
                      >
                      Clear All
                    </button>
                  </div>

                  {mode === 'line' && linePoints.length > 0 && (
                  <button onClick={()=> {
                    setLinePoints([]);
                    setPreviewLine(null);
                    }}
                    className="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700 text-sm"
                    >
                    Cancel Line
                  </button>
                  )}
                </div>

                <div className="border rounded p-4 bg-gray-50 relative">
                  <svg ref={svgRef} className={`w-full h-96 bg-white border ${ mode==='erase' ? isErasing
                    ? 'cursor-grabbing' : 'cursor-grab' : 'cursor-default' }`} onClick={handleClick}
                    onMouseMove={handleMouseMove} onMouseDown={(e)=> {
                    if (mode === 'erase') {
                    e.preventDefault();
                    const { x, y } = getCoordinates(e);
                    eraseAtPoint(x, y);
                    setIsErasing(true);
                    }
                    }}
                    onMouseUp={() => {
                    stopDragging();
                    setIsErasing(false);
                    }}
                    onMouseLeave={() => {
                    stopDragging();
                    setIsErasing(false);
                    }}
                    >
                    <defs>
                      <pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse">
                        <path d="M 10 0 L 0 0 0 10" fill="none" stroke="gray" strokeWidth="0.5" strokeOpacity="0.2" />
                      </pattern>
                    </defs>
                    <rect width="100%" height="100%" fill="url(#grid)" />

                    {/* Decorative circle */}
                    <circle cx="50%" cy="50%" r="180" fill="none" stroke="#87CEEB" strokeWidth="1"
                      strokeOpacity="0.5" />

                    {mirroringEnabled && (
                    <rect x={`calc(50% - ${CENTER_ZONE_WIDTH / 2}px)`} y="0" width={`${CENTER_ZONE_WIDTH}px`}
                      height="100%" fill="#ffebee" />
                    )}

                    {mirroringEnabled && (
                    <line x1="50%" y1="0" x2="50%" y2="100%" stroke="#4f46e5" strokeWidth="1" strokeDasharray="4,4"
                      strokeOpacity="0.5" />
                    )}

                    {previewLine && (
                    <g>
                      <line x1={previewLine.start.x} y1={previewLine.start.y} x2={previewLine.end.x}
                        y2={previewLine.end.y} stroke="#4f46e5" strokeWidth="1" strokeDasharray="4,4" />
                      {createPinsAlongLine(previewLine.start, previewLine.end).map((pin, i) => (
                      <circle key={`preview-${i}`} cx={pin.x} cy={pin.y} r="2" fill="#4f46e5" fillOpacity="0.3" />
                      ))}
                    </g>
                    )}

                    {linePoints.length === 1 && (
                    <circle cx={linePoints[0].x} cy={linePoints[0].y} r="4" fill="#4f46e5" />
                    )}

                    {pins.map(pin => (
                    <g key={pin.id}>
                      <circle cx={pin.x} cy={pin.y} r="3" fill="#4f46e5" cursor="move" onMouseDown={(e)=>
                        startDragging(e, pin)}
                        />
                        <circle cx={pin.x} cy={pin.y} r="1" fill="white" />
                    </g>
                    ))}
                  </svg>
                </div>

                <div className="space-y-2">
                  <p className="text-sm text-gray-600">
                    {mode === 'erase'
                    ? "Click and drag to erase pins and pockets."
                    : mode === 'single'
                    ? (mirroringEnabled
                    ? "Click to add mirrored pins. Pins in the center zone will be placed exactly in the middle."
                    : "Click anywhere to add pins. Drag pins to reposition.")
                    : mode === 'pocket'
                    ? "Click to add pockets. Select pocket type from the dropdown."
                    : "Click to set start point, then click again to create a line of pins."}
                    {" "}Click the red × to remove pins.
                  </p>
                  <button onClick={exportCoordinates}
                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                    Export Coordinates
                  </button>
                </div>
              </div>
            </CardContent>
          </Card>
          );
          };

          export default PachinkoPinEditor;